<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Three.js Color Grid Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: url('assets/bg.jpg') center center / cover no-repeat fixed;
        }

        canvas {
            display: block;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
</head>

<body>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        // Set scene background to bg.jpg
        const loader = new THREE.TextureLoader();
        loader.load('assets/bg.jpg', function (texture) {
            scene.background = texture;
        });

        // Camera setup (45 degree angle)
        const aspect = window.innerWidth / window.innerHeight;
        const d = 20;
        const camera = new THREE.OrthographicCamera(
            -d * aspect, d * aspect, d, -d, 1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0); // transparent background
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Grid parameters
        const gridSizeX = 10;
        const gridSizeZ = 20;
        const cellSize = 2;
        // Five pastel colors + brown
        const colors = [
            0xffb3ba, // pastel pink
            0xbaffc9, // pastel green
            0xffffba, // pastel yellow
            0xbae1ff, // pastel blue
            0xe2baff, // pastel purple
            0x8B5A2B  // brown
        ];

        // Store elevated cubes for interaction
        const elevatedCubes = [];
        const cubeGrid = Array.from({ length: gridSizeX }, () => Array(gridSizeZ));
        // Randomly select 3 indices to skip in the front row (z = 0)
        const numMissing = 3;
        const missingFrontIndices = [];
        while (missingFrontIndices.length < numMissing) {
            const idx = Math.floor(Math.random() * gridSizeX);
            if (!missingFrontIndices.includes(idx)) missingFrontIndices.push(idx);
        }

        let selectableOutline = null;

        // Debug HUD for camera info
        const debugHud = document.createElement('div');
        debugHud.style.position = 'fixed';
        debugHud.style.bottom = '20px';
        debugHud.style.left = '20px';
        debugHud.style.background = 'rgba(0,0,0,0.6)';
        debugHud.style.color = '#fff';
        debugHud.style.fontFamily = 'monospace';
        debugHud.style.fontSize = '1.2em';
        debugHud.style.padding = '8px 16px';
        debugHud.style.borderRadius = '8px';
        debugHud.style.zIndex = '100';
        document.body.appendChild(debugHud);
        function updateDebugHud() {
            debugHud.textContent = `cameraTargetZ: ${cameraTargetZ.toFixed(2)}\ncameraAngle: ${(cameraAngle * 180 / Math.PI).toFixed(1)}°`;
        }
        // --- Regular block addition commented out ---
        /*
        for (let x = 0; x < gridSizeX; x++) {
            for (let z = 0; z < gridSizeZ; z++) {
                // Skip random elevated cubes in the front row (z = 0)
                if (z === 0 && missingFrontIndices.includes(x)) continue;
                const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
                const color = colors[Math.floor(Math.random() * colors.length)];
                // Set semi-transparent for blue, opaque for brown
                const isBrown = color === 0x8B5A2B;
                const material = new THREE.MeshPhongMaterial({ color, transparent: true, opacity: isBrown ? 1 : 0.95 });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(
                    (x - gridSizeX / 2 + 0.5) * cellSize,
                    cellSize * 1.5,
                    (z - gridSizeZ / 2 + 0.5) * cellSize
                );
                cube.userData = { x, z, color };
                scene.add(cube);
                elevatedCubes.push(cube);
                cubeGrid[x][z] = cube;
            }
        }
        */
        // --- Only place blocks for the solvable path below ---
        // Generate a complex solution path with multi-swap and branching
        function generateSolvableHorizontalPath(N = 2, difficulty = 0.3) {
            // difficulty = 0..1 → chance of adding "forced swap" or "detour" events
            const path = [];
            const blueColors = colors.slice(0, 5);
            let prevXs = null;

            for (let z = 0; z < gridSizeZ; z++) {
                // Pick two colors for this row
                const colorA = blueColors[Math.floor(Math.random() * blueColors.length)];
                let colorB = blueColors[Math.floor(Math.random() * blueColors.length)];
                while (colorB === colorA) {
                    colorB = blueColors[Math.floor(Math.random() * blueColors.length)];
                }

                let startX;
                if (prevXs) {
                    // Pick a connection point from previous row
                    const connectX = prevXs[Math.floor(Math.random() * prevXs.length)];

                    // Zigzag chance: sometimes shift the path left/right to force swaps later
                    let offset = 0;
                    if (Math.random() < difficulty) {
                        offset = (Math.random() < 0.5 ? -1 : 1); // shift left or right
                    }
                    startX = Math.max(0, Math.min(connectX - Math.floor(N / 2) + offset, gridSizeX - N));
                } else {
                    startX = Math.floor(Math.random() * (gridSizeX - N + 1));
                }

                const xs = [];
                for (let i = 0; i < N; i++) {
                    xs.push(startX + i);

                    // Force-swap mechanic: sometimes put a mismatched color that requires a later swap
                    let chosenColor;
                    if (Math.random() < difficulty && i === 0 && z > 0) {
                        // Place a "wrong" color at the first slot to break the pair
                        const wrongColors = blueColors.filter(c => c !== colorA && c !== colorB);
                        chosenColor = wrongColors[Math.floor(Math.random() * wrongColors.length)];
                    } else {
                        chosenColor = (i % 2 === 0 ? colorA : colorB);
                    }

                    path.push({ x: startX + i, z, color: chosenColor });
                }

                prevXs = xs;
            }

            // Sprinkle some obstacles near the path (but not on it)
            const obstacleChance = 0.15;
            for (let i = 0; i < path.length; i++) {
                const { x, z } = path[i];
                // Look at neighbors of the path
                const neighbors = [
                    { nx: x - 1, nz: z },
                    { nx: x + 1, nz: z },
                ];
                neighbors.forEach(({ nx, nz }) => {
                    if (nx >= 0 && nx < gridSizeX && Math.random() < obstacleChance) {
                        // Ensure we don't overwrite the path
                        if (!path.some(p => p.x === nx && p.z === nz)) {
                            path.push({ x: nx, z: nz, color: 0x8B5A2B }); // brown obstacle
                        }
                    }
                });
            }

            return path;
        }

        const path = generateSolvableHorizontalPath();
        const pathSet = new Set(path.map(p => `${p.x},${p.z}`));
        for (const { x, z, color } of path) {
            const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
            const material = new THREE.MeshPhongMaterial({ color, transparent: true, opacity: 0.95 });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(
                (x - gridSizeX / 2 + 0.5) * cellSize,
                cellSize * 1.5,
                (z - gridSizeZ / 2 + 0.5) * cellSize
            );
            cube.userData = { x, z, color };
            scene.add(cube);
            elevatedCubes.push(cube);
            cubeGrid[x][z] = cube;
            // Highlight path cubes with wireframe
            const wireframe = new THREE.LineSegments(
                new THREE.EdgesGeometry(geometry),
                new THREE.LineBasicMaterial({ color: 0x00ffcc, linewidth: 2 })
            );
            wireframe.position.copy(cube.position);
            wireframe.position.y += 0.02; // Slightly above the cube
            // scene.add(wireframe);
        }
        // Fill the rest of the grid with random blocks(blue or brown), skipping path blocks
        for (let x = 0; x < gridSizeX; x++) {
            for (let z = 0; z < gridSizeZ; z++) {
                if (pathSet.has(`${x},${z}`)) continue;
                // Randomly choose blue or brown
                const color = colors[Math.floor(Math.random() * colors.length)];
                const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
                const isBrown = color === 0x8B5A2B;
                const material = new THREE.MeshPhongMaterial({ color, transparent: true, opacity: isBrown ? 1 : 0.95 });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(
                    (x - gridSizeX / 2 + 0.5) * cellSize,
                    cellSize * 1.5,
                    (z - gridSizeZ / 2 + 0.5) * cellSize
                );
                cube.userData = { x, z, color };
                scene.add(cube);
                elevatedCubes.push(cube);
                cubeGrid[x][z] = cube;
            }
        }

        // Add ground blocks with same height as cubes (no missing blocks)
        for (let x = 0; x < gridSizeX; x++) {
            for (let z = 0; z < gridSizeZ; z++) {
                const groundGeometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
                const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x00334d, side: THREE.DoubleSide }); // deep icey blue
                const groundCube = new THREE.Mesh(groundGeometry, groundMaterial);
                groundCube.position.set(
                    (x - gridSizeX / 2 + 0.5) * cellSize,
                    cellSize / 2, // base level
                    (z - gridSizeZ / 2 + 0.5) * cellSize
                );
                groundCube.receiveShadow = true;
                scene.add(groundCube);
            }
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(20, 40, 20);
        scene.add(directionalLight);

        // Raycaster for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let selectedCube = null;
        let selectedStroke = null;

        function highlightCube(cube) {
            // Remove previous stroke
            if (selectedStroke) {
                scene.remove(selectedStroke);
                selectedStroke = null;
            }
            // Add stroke to selected cube
            const geometry = cube.geometry;
            const edges = new THREE.EdgesGeometry(geometry);
            const stroke = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xff4444, linewidth: 4 }));
            stroke.position.copy(cube.position);
            stroke.position.y += 0.01;
            scene.add(stroke);
            selectedStroke = stroke;
        }

        function removeStroke() {
            if (selectedStroke) {
                scene.remove(selectedStroke);
                selectedStroke = null;
            }
        }

        function fadeOutCube(cube, callback) {
            // Prevent brown blocks from being removed
            if (cube.userData.color === 0x8B5A2B) return;
            let opacity = cube.material.opacity;
            let y = cube.position.y;
            const fadeSpeed = 0.05;
            const fallSpeed = 0.1;
            function fade() {
                opacity -= fadeSpeed;
                y -= fallSpeed;
                cube.position.y = y;
                if (opacity <= 0) {
                    cube.visible = false;
                    cube.material.opacity = 1; // Reset for future use
                    cube.position.y = cellSize * 1.5; // Reset position for future use
                    // Remove from cubeGrid so selectability updates
                    cubeGrid[cube.userData.x][cube.userData.z] = undefined;
                    updateCamera(); // Update camera position in real time
                    updateMoveStatus();
                    if (callback) callback();
                } else {
                    cube.material.transparent = true;
                    cube.material.opacity = opacity;
                    requestAnimationFrame(fade);
                }
            }
            fade();
        }

        function hasSameColorNeighbor(x, z, color) {
            const adj = [
                { x: x - 1, z },
                { x: x + 1, z },
                { x, z: z - 1 },
                { x, z: z + 1 }
            ];
            for (const { x: nx, z: nz } of adj) {
                if (
                    nx >= 0 && nx < gridSizeX &&
                    nz >= 0 && nz < gridSizeZ &&
                    cubeGrid[nx][nz] && cubeGrid[nx][nz].visible && cubeGrid[nx][nz].userData.color === color
                ) {
                    return true;
                }
            }
            return false;
        }

        function removeAdjacent(x, z, color) {
            if (!hasSameColorNeighbor(x, z, color)) return; // Don't remove if no neighbor of same color
            const toHide = [{ x, z }];
            const visited = Array.from({ length: gridSizeX }, () => Array(gridSizeZ).fill(false));
            visited[x][z] = true;
            while (toHide.length > 0) {
                const { x: cx, z: cz } = toHide.pop();
                const cube = cubeGrid[cx][cz];
                if (cube && cube.visible && cube.userData.color === color) {
                    fadeOutCube(cube);
                    // Check adjacent
                    const adj = [
                        { x: cx - 1, z: cz },
                        { x: cx + 1, z: cz },
                        { x: cx, z: cz - 1 },
                        { x: cx, z: cz + 1 }
                    ];
                    for (const { x: nx, z: nz } of adj) {
                        if (
                            nx >= 0 && nx < gridSizeX &&
                            nz >= 0 && nz < gridSizeZ &&
                            !visited[nx][nz]
                        ) {
                            visited[nx][nz] = true;
                            if (cubeGrid[nx][nz] && cubeGrid[nx][nz].visible && cubeGrid[nx][nz].userData.color === color) {
                                toHide.push({ x: nx, z: nz });
                            }
                        }
                    }
                }
            }
        }

        function isNeighbor(cubeA, cubeB) {
            const dx = Math.abs(cubeA.userData.x - cubeB.userData.x);
            const dz = Math.abs(cubeA.userData.z - cubeB.userData.z);
            return (dx === 1 && dz === 0) || (dx === 0 && dz === 1);
        }

        function isSelectable(x, z) {
            // Brown blocks are never selectable
            if (cubeGrid[x][z] && cubeGrid[x][z].userData.color === 0x8B5A2B) return false;
            // Make z=0 blocks always selectable
            if (z === 0) return true;
            // Check if any adjacent cell is empty (no cube)
            const adj = [
                { x: x - 1, z },
                { x: x + 1, z },
                { x, z: z - 1 },
                { x, z: z + 1 }
            ];
            for (const { x: nx, z: nz } of adj) {
                if (
                    nx >= 0 && nx < gridSizeX &&
                    nz >= 0 && nz < gridSizeZ &&
                    !cubeGrid[nx][nz] // empty space
                ) {
                    return true;
                }
            }
            return false;
        }

        // Add UI for available moves
        const moveStatus = document.createElement('div');
        moveStatus.style.position = 'fixed';
        moveStatus.style.top = '20px';
        moveStatus.style.left = '50%';
        moveStatus.style.transform = 'translateX(-50%)';
        moveStatus.style.fontSize = '2em';
        moveStatus.style.color = '#fff';
        moveStatus.style.textShadow = '0 2px 8px #00334d';
        moveStatus.style.fontFamily = 'Arial, sans-serif';
        moveStatus.style.zIndex = '10';
        // document.body.appendChild(moveStatus);
        function updateMoveStatus() {
            moveStatus.textContent = hasAvailableMove() ? 'Moves available' : 'No moves left';
        }

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            // Only allow selection of cubes next to an empty space and not brown
            const selectableCubes = elevatedCubes.filter(cube => cube.visible && isSelectable(cube.userData.x, cube.userData.z));
            const intersects = raycaster.intersectObjects(selectableCubes);
            if (intersects.length > 0) {
                const clickedCube = intersects[0].object;
                // Prevent interaction with brown blocks
                if (clickedCube.userData.color === 0x8B5A2B) return;
                // If the selected block has a neighbor of the same color, remove the whole chunk
                if (hasSameColorNeighbor(clickedCube.userData.x, clickedCube.userData.z, clickedCube.userData.color)) {
                    removeAdjacent(clickedCube.userData.x, clickedCube.userData.z, clickedCube.userData.color);
                    selectedCube = null;
                    removeStroke();
                    return;
                }
                if (!selectedCube) {
                    selectedCube = clickedCube;
                    highlightCube(clickedCube);
                } else if (selectedCube !== clickedCube) {
                    if (isNeighbor(selectedCube, clickedCube)) {
                        // Remove selection stroke before animating swap
                        removeStroke();
                        // Animate swap, then swap logic and removal
                        animateSwap(selectedCube, clickedCube, () => {
                            // Swap grid references
                            const temp = cubeGrid[selectedCube.userData.x][selectedCube.userData.z];
                            cubeGrid[selectedCube.userData.x][selectedCube.userData.z] = cubeGrid[clickedCube.userData.x][clickedCube.userData.z];
                            cubeGrid[clickedCube.userData.x][clickedCube.userData.z] = temp;
                            // Swap userData positions
                            const tempX = selectedCube.userData.x, tempZ = selectedCube.userData.z;
                            selectedCube.userData.x = clickedCube.userData.x;
                            selectedCube.userData.z = clickedCube.userData.z;
                            clickedCube.userData.x = tempX;
                            clickedCube.userData.z = tempZ;
                            // Remove adjacent cubes for both moved cubes
                            removeAdjacent(selectedCube.userData.x, selectedCube.userData.z, selectedCube.userData.color);
                            removeAdjacent(clickedCube.userData.x, clickedCube.userData.z, clickedCube.userData.color);
                            selectedCube = null;
                            updateMoveStatus();
                        });
                    } else {
                        // Not a neighbor: select the new cube
                        selectedCube = clickedCube;
                        highlightCube(clickedCube);
                    }
                }
            } else {
                // Clicked outside, deselect
                selectedCube = null;
                removeStroke();
            }
            updateMoveStatus();
        }
        window.addEventListener('click', onClick);

        // Touch interaction for selecting/swapping cubes
        window.addEventListener('touchend', function (e) {
            if (e.changedTouches && e.changedTouches.length === 1) {
                const touch = e.changedTouches[0];
                // Simulate a click event at the touch location
                const simulatedEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                onClick(simulatedEvent);
            }
        });

        // Camera rotation
        let cameraAngle;
        let cameraTargetAngle;
        const cameraRadius = 28;
        // Set default rotation to a pleasing angle (e.g., 45 degrees)
        cameraAngle = cameraTargetAngle = 9 * Math.PI / 10; // ~162 degrees

        function getFurthestRowWithEmpty() {
            // Find the furthest z (highest z) with at least one empty block
            for (let z = gridSizeZ - 1; z >= 0; z--) {
                for (let x = 0; x < gridSizeX; x++) {
                    if (!cubeGrid[x][z]) {
                        return z;
                    }
                }
            }
            return Math.floor(gridSizeZ / 2); // fallback: center
        }

        // Camera smooth movement state
        let cameraTargetZ = 0; // Start focused on front row (z=0)
        let cameraCurrentZ = cameraTargetZ;

        // Add win text element
        const winText = document.createElement('div');
        winText.textContent = 'You won!';
        winText.style.position = 'fixed';
        winText.style.top = '50%';
        winText.style.left = '50%';
        winText.style.transform = 'translate(-50%, -50%)';
        winText.style.fontSize = '3em';
        winText.style.color = '#fff';
        winText.style.textShadow = '0 2px 8px #00334d';
        winText.style.fontFamily = '"Press Start 2P", "VT323", "Courier New", monospace';
        winText.style.zIndex = '10';
        winText.style.display = 'none';
        document.body.appendChild(winText);

        function checkWin() {
            // Furthest row is gridSizeZ - 1
            for (let x = 0; x < gridSizeX; x++) {
                if (!cubeGrid[x][gridSizeZ - 1]) {
                    winText.style.display = 'block';
                    return true;
                }
            }
            winText.style.display = 'none';
            return false;
        }

        function updateCamera() {
            // Center camera on furthest row with empty blocks
            cameraTargetZ = getFurthestRowWithEmpty();
            checkWin();
        }

        function hasAvailableMove() {
            // Check for any selectable cube that can be removed (has same color neighbor)
            for (let x = 0; x < gridSizeX; x++) {
                for (let z = 0; z < gridSizeZ; z++) {
                    const cube = cubeGrid[x][z];
                    if (
                        cube && cube.visible &&
                        isSelectable(x, z) &&
                        cube.userData.color !== 0x8B5A2B &&
                        hasSameColorNeighbor(x, z, cube.userData.color)
                    ) {
                        return true;
                    }
                }
            }
            // Check for any possible swap between neighbors that would create a removable chunk
            for (let x = 0; x < gridSizeX; x++) {
                for (let z = 0; z < gridSizeZ; z++) {
                    const cubeA = cubeGrid[x][z];
                    if (!cubeA || !cubeA.visible || cubeA.userData.color === 0x8B5A2B) continue;
                    const neighbors = [
                        [x - 1, z], [x + 1, z], [x, z - 1], [x, z + 1]
                    ];
                    for (const [nx, nz] of neighbors) {
                        if (
                            nx >= 0 && nx < gridSizeX &&
                            nz >= 0 && nz < gridSizeZ
                        ) {
                            const cubeB = cubeGrid[nx][nz];
                            if (!cubeB || !cubeB.visible || cubeB.userData.color === 0x8B5A2B) continue;
                            // Simulate swap
                            const colorA = cubeA.userData.color;
                            const colorB = cubeB.userData.color;
                            // After swap, would either cube be removable?
                            if (
                                hasSameColorNeighbor(nx, nz, colorA) ||
                                hasSameColorNeighbor(x, z, colorB)
                            ) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Animation for swapping two cubes
        function animateSwap(cubeA, cubeB, onComplete) {
            const startA = cubeA.position.clone();
            const startB = cubeB.position.clone();
            const endA = startB.clone();
            const endB = startA.clone();
            const duration = 300; // ms
            const startTime = performance.now();
            function animate() {
                const now = performance.now();
                const t = Math.min((now - startTime) / duration, 1);
                cubeA.position.lerpVectors(startA, endA, t);
                cubeB.position.lerpVectors(startB, endB, t);
                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    cubeA.position.copy(endA);
                    cubeB.position.copy(endB);
                    if (onComplete) onComplete();
                }
            }
            animate();
        }

        let selectableClonesGroup = null;

        function updateSelectableClones() {
            // Remove previous group
            if (selectableClonesGroup) {
                scene.remove(selectableClonesGroup);
                selectableClonesGroup = null;
            }
            selectableClonesGroup = new THREE.Group();
            for (let x = 0; x < gridSizeX; x++) {
                for (let z = 0; z < gridSizeZ; z++) {
                    const cube = cubeGrid[x][z];
                    if (cube && cube.visible && isSelectable(x, z)) {
                        // Clone geometry and material
                        const clone = new THREE.Mesh(
                            cube.geometry.clone(),
                            new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: false })
                        );
                        clone.position.copy(cube.position);
                        clone.position.y += 2; // Slightly above original
                        clone.renderOrder = 1001;
                        selectableClonesGroup.add(clone);
                    }
                }
            }
            // scene.add(selectableClonesGroup);
        }

        // Render loop
        function animate() {
            // Smoothly interpolate cameraCurrentZ toward cameraTargetZ
            cameraCurrentZ += (cameraTargetZ - cameraCurrentZ) * 0.1;
            // Smoothly interpolate cameraAngle toward cameraTargetAngle
            cameraAngle += (cameraTargetAngle - cameraAngle) * 0.1;
            camera.position.set(
                Math.sin(cameraAngle) * cameraRadius,
                20,
                Math.cos(cameraAngle) * cameraRadius + (cameraCurrentZ - gridSizeZ / 2) * cellSize
            );
            camera.lookAt(0, 0, (cameraCurrentZ - gridSizeZ / 2) * cellSize);
            updateDebugHud();
            updateSelectableClones();
            renderer.render(scene, camera);
            updateMoveStatus();
            requestAnimationFrame(animate);
        }
        animate();

        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                cameraTargetAngle -= Math.PI / 16;
            } else if (e.key === 'ArrowRight') {
                cameraTargetAngle += Math.PI / 16;
            } else if (e.key === 'ArrowUp') {
                cameraTargetZ = Math.min(cameraTargetZ + 1, gridSizeZ - 1);
            } else if (e.key === 'ArrowDown') {
                cameraTargetZ = Math.max(cameraTargetZ - 1, 0);
            }
        });

        // Touch controls for camera rotation
        let touchStartX = null;
        let touchStartY = null;
        let touchActive = false;
        window.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchActive = true;
            }
        });
        window.addEventListener('touchmove', (e) => {
            if (touchActive && e.touches.length === 1) {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const deltaX = touchX - touchStartX;
                const deltaY = touchY - touchStartY;
                // Horizontal swipe for camera rotation
                if (Math.abs(deltaX) > 20 && Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (deltaX < 0) {
                        cameraTargetAngle += Math.PI / 32;
                    } else {
                        cameraTargetAngle -= Math.PI / 32;
                    }
                    touchStartX = touchX;
                    touchStartY = touchY;
                }
                // Vertical swipe for cameraTargetZ
                if (Math.abs(deltaY) > 10 && Math.abs(deltaY) > Math.abs(deltaX)) {
                    // Sliding up: decrease cameraTargetZ
                    if (deltaY < 0) {
                        cameraTargetZ = Math.max(cameraTargetZ - 0.2, 0);
                    } else {
                        cameraTargetZ = Math.min(cameraTargetZ + 0.2, gridSizeZ - 1);
                    }
                    touchStartX = touchX;
                    touchStartY = touchY;
                }
            }
        });
        window.addEventListener('touchend', () => {
            touchActive = false;
            touchStartX = null;
            touchStartY = null;
        });

        // Responsive resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>