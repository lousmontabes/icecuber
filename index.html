<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Three.js Color Grid Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: url('assets/bg.jpg') center center / cover no-repeat fixed;
        }

        canvas {
            display: block;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
</head>

<body>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        // Set scene background to bg.jpg
        const loader = new THREE.TextureLoader();
        loader.load('assets/bg.jpg', function (texture) {
            scene.background = texture;
        });

        // Camera setup (45 degree angle)
        const aspect = window.innerWidth / window.innerHeight;
        const d = 20;
        const camera = new THREE.OrthographicCamera(
            -d * aspect, d * aspect, d, -d, 1, 1000
        );
        camera.position.set(20, 20, 20); // 45 degree angle
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0); // transparent background
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Grid parameters
        const gridSizeX = 10;
        const gridSizeZ = 20;
        const cellSize = 2;
        // Five icy blue shades + brown
        const colors = [0xb3e6ff, 0x99d6ea, 0x80c6d4, 0x66b6bf, 0x4da6aa, 0x8B5A2B]; // brown added

        // Store elevated cubes for interaction
        const elevatedCubes = [];
        const cubeGrid = Array.from({ length: gridSizeX }, () => Array(gridSizeZ));
        // Randomly select 3 indices to skip in the front row (z = 0)
        const numMissing = 3;
        const missingFrontIndices = [];
        while (missingFrontIndices.length < numMissing) {
            const idx = Math.floor(Math.random() * gridSizeX);
            if (!missingFrontIndices.includes(idx)) missingFrontIndices.push(idx);
        }
        for (let x = 0; x < gridSizeX; x++) {
            for (let z = 0; z < gridSizeZ; z++) {
                // Skip random elevated cubes in the front row (z = 0)
                if (z === 0 && missingFrontIndices.includes(x)) continue;
                const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
                const color = colors[Math.floor(Math.random() * colors.length)];
                // Set semi-transparent for blue, opaque for brown
                const isBrown = color === 0x8B5A2B;
                const material = new THREE.MeshPhongMaterial({ color, transparent: true, opacity: isBrown ? 1 : 0.85 });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(
                    (x - gridSizeX / 2 + 0.5) * cellSize,
                    cellSize * 1.5,
                    (z - gridSizeZ / 2 + 0.5) * cellSize
                );
                cube.userData = { x, z, color };
                scene.add(cube);
                elevatedCubes.push(cube);
                cubeGrid[x][z] = cube;
            }
        }

        // Add ground blocks with same height as cubes (no missing blocks)
        for (let x = 0; x < gridSizeX; x++) {
            for (let z = 0; z < gridSizeZ; z++) {
                const groundGeometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
                const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x00334d, side: THREE.DoubleSide }); // deep icey blue
                const groundCube = new THREE.Mesh(groundGeometry, groundMaterial);
                groundCube.position.set(
                    (x - gridSizeX / 2 + 0.5) * cellSize,
                    cellSize / 2, // base level
                    (z - gridSizeZ / 2 + 0.5) * cellSize
                );
                groundCube.receiveShadow = true;
                scene.add(groundCube);
            }
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(20, 40, 20);
        scene.add(directionalLight);

        // Raycaster for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let selectedCube = null;
        let selectedStroke = null;

        function highlightCube(cube) {
            // Remove previous stroke
            if (selectedStroke) {
                scene.remove(selectedStroke);
                selectedStroke = null;
            }
            // Add stroke to selected cube
            const geometry = cube.geometry;
            const edges = new THREE.EdgesGeometry(geometry);
            const stroke = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xff4444, linewidth: 4 }));
            stroke.position.copy(cube.position);
            stroke.position.y += 0.01;
            scene.add(stroke);
            selectedStroke = stroke;
        }

        function removeStroke() {
            if (selectedStroke) {
                scene.remove(selectedStroke);
                selectedStroke = null;
            }
        }

        function fadeOutCube(cube, callback) {
            // Prevent brown blocks from being removed
            if (cube.userData.color === 0x8B5A2B) return;
            let opacity = cube.material.opacity;
            let y = cube.position.y;
            const fadeSpeed = 0.05;
            const fallSpeed = 0.1;
            function fade() {
                opacity -= fadeSpeed;
                y -= fallSpeed;
                cube.position.y = y;
                if (opacity <= 0) {
                    cube.visible = false;
                    cube.material.opacity = 1; // Reset for future use
                    cube.position.y = cellSize * 1.5; // Reset position for future use
                    // Remove from cubeGrid so selectability updates
                    cubeGrid[cube.userData.x][cube.userData.z] = undefined;
                    updateCamera(); // Update camera position in real time
                    updateMoveStatus();
                    if (callback) callback();
                } else {
                    cube.material.transparent = true;
                    cube.material.opacity = opacity;
                    requestAnimationFrame(fade);
                }
            }
            fade();
        }

        function hasSameColorNeighbor(x, z, color) {
            const adj = [
                { x: x - 1, z },
                { x: x + 1, z },
                { x, z: z - 1 },
                { x, z: z + 1 }
            ];
            for (const { x: nx, z: nz } of adj) {
                if (
                    nx >= 0 && nx < gridSizeX &&
                    nz >= 0 && nz < gridSizeZ &&
                    cubeGrid[nx][nz] && cubeGrid[nx][nz].visible && cubeGrid[nx][nz].userData.color === color
                ) {
                    return true;
                }
            }
            return false;
        }

        function removeAdjacent(x, z, color) {
            if (!hasSameColorNeighbor(x, z, color)) return; // Don't remove if no neighbor of same color
            const toHide = [{ x, z }];
            const visited = Array.from({ length: gridSizeX }, () => Array(gridSizeZ).fill(false));
            visited[x][z] = true;
            while (toHide.length > 0) {
                const { x: cx, z: cz } = toHide.pop();
                const cube = cubeGrid[cx][cz];
                if (cube && cube.visible && cube.userData.color === color) {
                    fadeOutCube(cube);
                    // Check adjacent
                    const adj = [
                        { x: cx - 1, z: cz },
                        { x: cx + 1, z: cz },
                        { x: cx, z: cz - 1 },
                        { x: cx, z: cz + 1 }
                    ];
                    for (const { x: nx, z: nz } of adj) {
                        if (
                            nx >= 0 && nx < gridSizeX &&
                            nz >= 0 && nz < gridSizeZ &&
                            !visited[nx][nz]
                        ) {
                            visited[nx][nz] = true;
                            if (cubeGrid[nx][nz] && cubeGrid[nx][nz].visible && cubeGrid[nx][nz].userData.color === color) {
                                toHide.push({ x: nx, z: nz });
                            }
                        }
                    }
                }
            }
        }

        function isNeighbor(cubeA, cubeB) {
            const dx = Math.abs(cubeA.userData.x - cubeB.userData.x);
            const dz = Math.abs(cubeA.userData.z - cubeB.userData.z);
            return (dx === 1 && dz === 0) || (dx === 0 && dz === 1);
        }

        function isSelectable(x, z) {
            // Brown blocks are never selectable
            if (cubeGrid[x][z] && cubeGrid[x][z].userData.color === 0x8B5A2B) return false;
            // Check if any adjacent cell is empty (no cube)
            const adj = [
                { x: x - 1, z },
                { x: x + 1, z },
                { x, z: z - 1 },
                { x, z: z + 1 }
            ];
            for (const { x: nx, z: nz } of adj) {
                if (
                    nx >= 0 && nx < gridSizeX &&
                    nz >= 0 && nz < gridSizeZ &&
                    !cubeGrid[nx][nz] // empty space
                ) {
                    return true;
                }
            }
            return false;
        }

        // Add UI for available moves
        const moveStatus = document.createElement('div');
        moveStatus.style.position = 'fixed';
        moveStatus.style.top = '20px';
        moveStatus.style.left = '50%';
        moveStatus.style.transform = 'translateX(-50%)';
        moveStatus.style.fontSize = '2em';
        moveStatus.style.color = '#fff';
        moveStatus.style.textShadow = '0 2px 8px #00334d';
        moveStatus.style.fontFamily = 'Arial, sans-serif';
        moveStatus.style.zIndex = '10';
        // document.body.appendChild(moveStatus);
        function updateMoveStatus() {
            moveStatus.textContent = hasAvailableMove() ? 'Moves available' : 'No moves left';
        }

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            // Only allow selection of cubes next to an empty space and not brown
            const selectableCubes = elevatedCubes.filter(cube => cube.visible && isSelectable(cube.userData.x, cube.userData.z));
            const intersects = raycaster.intersectObjects(selectableCubes);
            if (intersects.length > 0) {
                const clickedCube = intersects[0].object;
                // Prevent interaction with brown blocks
                if (clickedCube.userData.color === 0x8B5A2B) return;
                // If the selected block has a neighbor of the same color, remove the whole chunk
                if (hasSameColorNeighbor(clickedCube.userData.x, clickedCube.userData.z, clickedCube.userData.color)) {
                    removeAdjacent(clickedCube.userData.x, clickedCube.userData.z, clickedCube.userData.color);
                    selectedCube = null;
                    removeStroke();
                    return;
                }
                if (!selectedCube) {
                    selectedCube = clickedCube;
                    highlightCube(clickedCube);
                } else if (selectedCube !== clickedCube) {
                    if (isNeighbor(selectedCube, clickedCube)) {
                        // Remove selection stroke before animating swap
                        removeStroke();
                        // Animate swap, then swap logic and removal
                        animateSwap(selectedCube, clickedCube, () => {
                            // Swap grid references
                            const temp = cubeGrid[selectedCube.userData.x][selectedCube.userData.z];
                            cubeGrid[selectedCube.userData.x][selectedCube.userData.z] = cubeGrid[clickedCube.userData.x][clickedCube.userData.z];
                            cubeGrid[clickedCube.userData.x][clickedCube.userData.z] = temp;
                            // Swap userData positions
                            const tempX = selectedCube.userData.x, tempZ = selectedCube.userData.z;
                            selectedCube.userData.x = clickedCube.userData.x;
                            selectedCube.userData.z = clickedCube.userData.z;
                            clickedCube.userData.x = tempX;
                            clickedCube.userData.z = tempZ;
                            // Remove adjacent cubes for both moved cubes
                            removeAdjacent(selectedCube.userData.x, selectedCube.userData.z, selectedCube.userData.color);
                            removeAdjacent(clickedCube.userData.x, clickedCube.userData.z, clickedCube.userData.color);
                            selectedCube = null;
                            updateMoveStatus();
                        });
                    } else {
                        // Not a neighbor: select the new cube
                        selectedCube = clickedCube;
                        highlightCube(clickedCube);
                    }
                }
            } else {
                // Clicked outside, deselect
                selectedCube = null;
                removeStroke();
            }
            updateMoveStatus();
        }
        window.addEventListener('click', onClick);

        // Touch interaction for selecting/swapping cubes
        window.addEventListener('touchend', function (e) {
            if (e.changedTouches && e.changedTouches.length === 1) {
                const touch = e.changedTouches[0];
                // Simulate a click event at the touch location
                const simulatedEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                onClick(simulatedEvent);
            }
        });

        // Camera rotation
        let cameraAngle;
        const cameraRadius = 28;
        // Set default rotation to look toward the row with initially empty blocks
        const initialEmptyRow = (() => {
            for (let z = gridSizeZ - 1; z >= 0; z--) {
                for (let x = 0; x < gridSizeX; x++) {
                    if (!cubeGrid[x][z]) return z;
                }
            }
            return Math.floor(gridSizeZ / 2);
        })();
        // Calculate angle so camera looks toward the initial empty row, with a slight angle to the left
        cameraAngle = Math.atan2(0, (initialEmptyRow - gridSizeZ / 2) * cellSize + 1) - Math.PI / 12;
        function getFurthestRowWithEmpty() {
            // Find the furthest z (highest z) with at least one empty block
            for (let z = gridSizeZ - 1; z >= 0; z--) {
                for (let x = 0; x < gridSizeX; x++) {
                    if (!cubeGrid[x][z]) {
                        return z;
                    }
                }
            }
            return Math.floor(gridSizeZ / 2); // fallback: center
        }

        // Camera smooth movement state
        let cameraTargetZ = getFurthestRowWithEmpty();
        let cameraCurrentZ = cameraTargetZ;

        // Add win text element
        const winText = document.createElement('div');
        winText.textContent = 'You won!';
        winText.style.position = 'fixed';
        winText.style.top = '50%';
        winText.style.left = '50%';
        winText.style.transform = 'translate(-50%, -50%)';
        winText.style.fontSize = '3em';
        winText.style.color = '#fff';
        winText.style.textShadow = '0 2px 8px #00334d';
        winText.style.fontFamily = '"Press Start 2P", "VT323", "Courier New", monospace';
        winText.style.zIndex = '10';
        winText.style.display = 'none';
        document.body.appendChild(winText);

        function checkWin() {
            // Furthest row is gridSizeZ - 1
            for (let x = 0; x < gridSizeX; x++) {
                if (!cubeGrid[x][gridSizeZ - 1]) {
                    winText.style.display = 'block';
                    return true;
                }
            }
            winText.style.display = 'none';
            return false;
        }

        function updateCamera() {
            // Center camera on furthest row with empty blocks
            cameraTargetZ = getFurthestRowWithEmpty();
            checkWin();
        }

        function hasAvailableMove() {
            // Check for any selectable cube that can be removed (has same color neighbor)
            for (let x = 0; x < gridSizeX; x++) {
                for (let z = 0; z < gridSizeZ; z++) {
                    const cube = cubeGrid[x][z];
                    if (
                        cube && cube.visible &&
                        isSelectable(x, z) &&
                        cube.userData.color !== 0x8B5A2B &&
                        hasSameColorNeighbor(x, z, cube.userData.color)
                    ) {
                        return true;
                    }
                }
            }
            // Check for any possible swap between neighbors that would create a removable chunk
            for (let x = 0; x < gridSizeX; x++) {
                for (let z = 0; z < gridSizeZ; z++) {
                    const cubeA = cubeGrid[x][z];
                    if (!cubeA || !cubeA.visible || cubeA.userData.color === 0x8B5A2B) continue;
                    const neighbors = [
                        [x - 1, z], [x + 1, z], [x, z - 1], [x, z + 1]
                    ];
                    for (const [nx, nz] of neighbors) {
                        if (
                            nx >= 0 && nx < gridSizeX &&
                            nz >= 0 && nz < gridSizeZ
                        ) {
                            const cubeB = cubeGrid[nx][nz];
                            if (!cubeB || !cubeB.visible || cubeB.userData.color === 0x8B5A2B) continue;
                            // Simulate swap
                            const colorA = cubeA.userData.color;
                            const colorB = cubeB.userData.color;
                            // After swap, would either cube be removable?
                            if (
                                hasSameColorNeighbor(nx, nz, colorA) ||
                                hasSameColorNeighbor(x, z, colorB)
                            ) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Animation for swapping two cubes
        function animateSwap(cubeA, cubeB, onComplete) {
            const startA = cubeA.position.clone();
            const startB = cubeB.position.clone();
            const endA = startB.clone();
            const endB = startA.clone();
            const duration = 300; // ms
            const startTime = performance.now();
            function animate() {
                const now = performance.now();
                const t = Math.min((now - startTime) / duration, 1);
                cubeA.position.lerpVectors(startA, endA, t);
                cubeB.position.lerpVectors(startB, endB, t);
                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    cubeA.position.copy(endA);
                    cubeB.position.copy(endB);
                    if (onComplete) onComplete();
                }
            }
            animate();
        }

        // Render loop
        function animate() {
            // Smoothly interpolate cameraCurrentZ toward cameraTargetZ
            cameraCurrentZ += (cameraTargetZ - cameraCurrentZ) * 0.1;
            camera.position.set(
                Math.sin(cameraAngle) * cameraRadius,
                20,
                Math.cos(cameraAngle) * cameraRadius + (cameraCurrentZ - gridSizeZ / 2) * cellSize
            );
            camera.lookAt(0, 0, (cameraCurrentZ - gridSizeZ / 2) * cellSize);
            renderer.render(scene, camera);
            updateMoveStatus();
            requestAnimationFrame(animate);
        }
        animate();

        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                cameraAngle -= Math.PI / 16;
                updateCamera();
            } else if (e.key === 'ArrowRight') {
                cameraAngle += Math.PI / 16;
                updateCamera();
            }
        });

        // Touch controls for camera rotation
        let touchStartX = null;
        let touchActive = false;
        window.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchActive = true;
            }
        });
        window.addEventListener('touchmove', (e) => {
            if (touchActive && e.touches.length === 1) {
                const touchX = e.touches[0].clientX;
                const deltaX = touchX - touchStartX;
                if (Math.abs(deltaX) > 20) { // threshold for swipe
                    if (deltaX < 0) {
                        cameraAngle += Math.PI / 32;
                    } else {
                        cameraAngle -= Math.PI / 32;
                    }
                    updateCamera();
                    touchStartX = touchX;
                }
            }
        });
        window.addEventListener('touchend', () => {
            touchActive = false;
            touchStartX = null;
        });

        // Responsive resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>