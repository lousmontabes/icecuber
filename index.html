<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Three.js Color Grid Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
</head>

<body>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // Camera setup (45 degree angle)
        const aspect = window.innerWidth / window.innerHeight;
        const d = 20;
        const camera = new THREE.OrthographicCamera(
            -d * aspect, d * aspect, d, -d, 1, 1000
        );
        camera.position.set(20, 20, 20); // 45 degree angle
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Grid parameters
        const gridSizeX = 10;
        const gridSizeZ = 20;
        const cellSize = 2;
        // Five icy blue shades
        const colors = [0xb3e6ff, 0x99d6ea, 0x80c6d4, 0x66b6bf, 0x4da6aa];

        // Store elevated cubes for interaction
        const elevatedCubes = [];
        const cubeGrid = Array.from({ length: gridSizeX }, () => Array(gridSizeZ));
        // Randomly select 3 indices to skip in the front row (z = 0)
        const numMissing = 3;
        const missingFrontIndices = [];
        while (missingFrontIndices.length < numMissing) {
            const idx = Math.floor(Math.random() * gridSizeX);
            if (!missingFrontIndices.includes(idx)) missingFrontIndices.push(idx);
        }
        for (let x = 0; x < gridSizeX; x++) {
            for (let z = 0; z < gridSizeZ; z++) {
                // Skip random elevated cubes in the front row (z = 0)
                if (z === 0 && missingFrontIndices.includes(x)) continue;
                const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
                const color = colors[Math.floor(Math.random() * colors.length)];
                // Use MeshPhongMaterial for proper opacity fading
                const material = new THREE.MeshPhongMaterial({ color, transparent: true, opacity: 1 });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(
                    (x - gridSizeX / 2 + 0.5) * cellSize,
                    cellSize * 1.5,
                    (z - gridSizeZ / 2 + 0.5) * cellSize
                );
                cube.userData = { x, z, color };
                scene.add(cube);
                elevatedCubes.push(cube);
                cubeGrid[x][z] = cube;
            }
        }

        // Add ground blocks with same height as cubes (no missing blocks)
        for (let x = 0; x < gridSizeX; x++) {
            for (let z = 0; z < gridSizeZ; z++) {
                const groundGeometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
                const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x00334d, side: THREE.DoubleSide }); // deep icey blue
                const groundCube = new THREE.Mesh(groundGeometry, groundMaterial);
                groundCube.position.set(
                    (x - gridSizeX / 2 + 0.5) * cellSize,
                    cellSize / 2, // base level
                    (z - gridSizeZ / 2 + 0.5) * cellSize
                );
                groundCube.receiveShadow = true;
                scene.add(groundCube);
            }
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(20, 40, 20);
        scene.add(directionalLight);

        // Raycaster for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let selectedCube = null;
        let selectedStroke = null;

        function highlightCube(cube) {
            // Remove previous stroke
            if (selectedStroke) {
                scene.remove(selectedStroke);
                selectedStroke = null;
            }
            // Add stroke to selected cube
            const geometry = cube.geometry;
            const edges = new THREE.EdgesGeometry(geometry);
            const stroke = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xff4444, linewidth: 4 }));
            stroke.position.copy(cube.position);
            stroke.position.y += 0.01;
            scene.add(stroke);
            selectedStroke = stroke;
        }

        function removeStroke() {
            if (selectedStroke) {
                scene.remove(selectedStroke);
                selectedStroke = null;
            }
        }

        function fadeOutCube(cube, callback) {
            let opacity = cube.material.opacity;
            let y = cube.position.y;
            const fadeSpeed = 0.05;
            const fallSpeed = 0.1;
            function fade() {
                opacity -= fadeSpeed;
                y -= fallSpeed;
                cube.position.y = y;
                if (opacity <= 0) {
                    cube.visible = false;
                    cube.material.opacity = 1; // Reset for future use
                    cube.position.y = cellSize * 1.5; // Reset position for future use
                    // Remove from cubeGrid so selectability updates
                    cubeGrid[cube.userData.x][cube.userData.z] = undefined;
                    updateCamera(); // Update camera position in real time
                    if (callback) callback();
                } else {
                    cube.material.transparent = true;
                    cube.material.opacity = opacity;
                    requestAnimationFrame(fade);
                }
            }
            fade();
        }

        function hasSameColorNeighbor(x, z, color) {
            const adj = [
                { x: x - 1, z },
                { x: x + 1, z },
                { x, z: z - 1 },
                { x, z: z + 1 }
            ];
            for (const { x: nx, z: nz } of adj) {
                if (
                    nx >= 0 && nx < gridSizeX &&
                    nz >= 0 && nz < gridSizeZ &&
                    cubeGrid[nx][nz] && cubeGrid[nx][nz].visible && cubeGrid[nx][nz].userData.color === color
                ) {
                    return true;
                }
            }
            return false;
        }

        function removeAdjacent(x, z, color) {
            if (!hasSameColorNeighbor(x, z, color)) return; // Don't remove if no neighbor of same color
            const toHide = [{ x, z }];
            const visited = Array.from({ length: gridSizeX }, () => Array(gridSizeZ).fill(false));
            visited[x][z] = true;
            while (toHide.length > 0) {
                const { x: cx, z: cz } = toHide.pop();
                const cube = cubeGrid[cx][cz];
                if (cube && cube.visible && cube.userData.color === color) {
                    fadeOutCube(cube);
                    // Check adjacent
                    const adj = [
                        { x: cx - 1, z: cz },
                        { x: cx + 1, z: cz },
                        { x: cx, z: cz - 1 },
                        { x: cx, z: cz + 1 }
                    ];
                    for (const { x: nx, z: nz } of adj) {
                        if (
                            nx >= 0 && nx < gridSizeX &&
                            nz >= 0 && nz < gridSizeZ &&
                            !visited[nx][nz]
                        ) {
                            visited[nx][nz] = true;
                            if (cubeGrid[nx][nz] && cubeGrid[nx][nz].visible && cubeGrid[nx][nz].userData.color === color) {
                                toHide.push({ x: nx, z: nz });
                            }
                        }
                    }
                }
            }
        }

        function isNeighbor(cubeA, cubeB) {
            const dx = Math.abs(cubeA.userData.x - cubeB.userData.x);
            const dz = Math.abs(cubeA.userData.z - cubeB.userData.z);
            return (dx === 1 && dz === 0) || (dx === 0 && dz === 1);
        }

        function isSelectable(x, z) {
            // Check if any adjacent cell is empty (no cube)
            const adj = [
                { x: x - 1, z },
                { x: x + 1, z },
                { x, z: z - 1 },
                { x, z: z + 1 }
            ];
            for (const { x: nx, z: nz } of adj) {
                if (
                    nx >= 0 && nx < gridSizeX &&
                    nz >= 0 && nz < gridSizeZ &&
                    !cubeGrid[nx][nz] // empty space
                ) {
                    return true;
                }
            }
            return false;
        }

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            // Only allow selection of cubes next to an empty space
            const selectableCubes = elevatedCubes.filter(cube => cube.visible && isSelectable(cube.userData.x, cube.userData.z));
            const intersects = raycaster.intersectObjects(selectableCubes);
            if (intersects.length > 0) {
                const clickedCube = intersects[0].object;
                // If the selected block has a neighbor of the same color, remove the whole chunk
                if (hasSameColorNeighbor(clickedCube.userData.x, clickedCube.userData.z, clickedCube.userData.color)) {
                    removeAdjacent(clickedCube.userData.x, clickedCube.userData.z, clickedCube.userData.color);
                    selectedCube = null;
                    removeStroke();
                    return;
                }
                if (!selectedCube) {
                    selectedCube = clickedCube;
                    highlightCube(clickedCube);
                } else if (selectedCube !== clickedCube) {
                    // Allow swap with any neighbor, not just selectable ones
                    if (isNeighbor(selectedCube, clickedCube)) {
                        // Swap positions
                        const posA = selectedCube.position.clone();
                        const posB = clickedCube.position.clone();
                        selectedCube.position.copy(posB);
                        clickedCube.position.copy(posA);
                        // Swap grid references
                        const temp = cubeGrid[selectedCube.userData.x][selectedCube.userData.z];
                        cubeGrid[selectedCube.userData.x][selectedCube.userData.z] = cubeGrid[clickedCube.userData.x][clickedCube.userData.z];
                        cubeGrid[clickedCube.userData.x][clickedCube.userData.z] = temp;
                        // Swap userData positions
                        const tempX = selectedCube.userData.x, tempZ = selectedCube.userData.z;
                        selectedCube.userData.x = clickedCube.userData.x;
                        selectedCube.userData.z = clickedCube.userData.z;
                        clickedCube.userData.x = tempX;
                        clickedCube.userData.z = tempZ;
                        // Remove selection stroke
                        removeStroke();
                        // Remove adjacent cubes for both moved cubes
                        removeAdjacent(selectedCube.userData.x, selectedCube.userData.z, selectedCube.userData.color);
                        removeAdjacent(clickedCube.userData.x, clickedCube.userData.z, clickedCube.userData.color);
                        selectedCube = null;
                    } else {
                        // Not a neighbor: select the new cube
                        selectedCube = clickedCube;
                        highlightCube(clickedCube);
                    }
                }
            } else {
                // Clicked outside, deselect
                selectedCube = null;
                removeStroke();
            }
        }
        window.addEventListener('click', onClick);

        // Touch interaction for selecting/swapping cubes
        window.addEventListener('touchend', function (e) {
            if (e.changedTouches && e.changedTouches.length === 1) {
                const touch = e.changedTouches[0];
                // Simulate a click event at the touch location
                const simulatedEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                onClick(simulatedEvent);
            }
        });

        // Camera rotation
        let cameraAngle;
        const cameraRadius = 28;
        // Set default rotation to look toward the row with initially empty blocks
        const initialEmptyRow = (() => {
            for (let z = gridSizeZ - 1; z >= 0; z--) {
                for (let x = 0; x < gridSizeX; x++) {
                    if (!cubeGrid[x][z]) return z;
                }
            }
            return Math.floor(gridSizeZ / 2);
        })();
        // Calculate angle so camera looks toward the initial empty row, with a slight angle to the left
        cameraAngle = Math.atan2(0, (initialEmptyRow - gridSizeZ / 2) * cellSize + 1) - Math.PI / 12;
        function getFurthestRowWithEmpty() {
            // Find the furthest z (highest z) with at least one empty block
            for (let z = gridSizeZ - 1; z >= 0; z--) {
                for (let x = 0; x < gridSizeX; x++) {
                    if (!cubeGrid[x][z]) {
                        return z;
                    }
                }
            }
            return Math.floor(gridSizeZ / 2); // fallback: center
        }

        // Camera smooth movement state
        let cameraTargetZ = getFurthestRowWithEmpty();
        let cameraCurrentZ = cameraTargetZ;

        function updateCamera() {
            // Center camera on furthest row with empty blocks
            cameraTargetZ = getFurthestRowWithEmpty();
        }

        // Render loop
        function animate() {
            // Smoothly interpolate cameraCurrentZ toward cameraTargetZ
            cameraCurrentZ += (cameraTargetZ - cameraCurrentZ) * 0.1;
            camera.position.set(
                Math.sin(cameraAngle) * cameraRadius,
                20,
                Math.cos(cameraAngle) * cameraRadius + (cameraCurrentZ - gridSizeZ / 2) * cellSize
            );
            camera.lookAt(0, 0, (cameraCurrentZ - gridSizeZ / 2) * cellSize);
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                cameraAngle -= Math.PI / 16;
                updateCamera();
            } else if (e.key === 'ArrowRight') {
                cameraAngle += Math.PI / 16;
                updateCamera();
            }
        });

        // Touch controls for camera rotation
        let touchStartX = null;
        let touchActive = false;
        window.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchActive = true;
            }
        });
        window.addEventListener('touchmove', (e) => {
            if (touchActive && e.touches.length === 1) {
                const touchX = e.touches[0].clientX;
                const deltaX = touchX - touchStartX;
                if (Math.abs(deltaX) > 20) { // threshold for swipe
                    if (deltaX < 0) {
                        cameraAngle += Math.PI / 32;
                    } else {
                        cameraAngle -= Math.PI / 32;
                    }
                    updateCamera();
                    touchStartX = touchX;
                }
            }
        });
        window.addEventListener('touchend', () => {
            touchActive = false;
            touchStartX = null;
        });

        // Responsive resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>